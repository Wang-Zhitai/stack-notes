# 字符设备驱动

# 1. Linux应用程序如何调用驱动程序

* 字符设备是Linux驱动中最基本的一类设备驱动，字符设备就是一个一个字节按照字节流进行读写操作的设备，读写数据是分先后数据的，比如我们最常见的点灯、按键、I2C、SPI LCD等都是字符设备，这些设备的驱动就叫做字符设备驱动。

* 先来了解一下Linux下的应用程序是如何调用驱动程序的，调用流程如图所示：

![image-20251127081434493](./assets/image-20251127081434493.png)

* **在Linux中，一切皆文件**，驱动加载成功后，会在/dev目录下面生成一个相对应的文件。应用程序通过对这个名为/dev/xxx的文件进行相应的操作，即可实现对硬件的操作。比如我现在有一个叫做/dev/led的驱动文件，此文件是LED灯的驱动文件。应用程序通过 `open `函数打开文件，使用完成后使用 `close` 函数关闭文件。 Open和close就是打开和关闭LED驱动的函数。如果要点亮或者关闭LED，那就使用write函数来操作，也就是向此函数写入数据。这个数据就是是要关闭还是打开LED的控制参数。如果要获取LED灯的状态。就用read函数从驱动中读取相应的状态。

* 应用程序运行在用户空间，而Linux驱动运行于内核空间。当我们在用户空间想要实现对内核的操作，比如使用open函数打开LED驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做**系统调用**的方法来实现从**用户空间陷入到内核空间**，这样才能实现对底层驱动的操作。open、close、write、read这些函数是由C库提供的。在Linux系统中，系统调用作为C库的一部分。当我们调用open函数的时候的流程如图所示：

![image-20251127082425023](./assets/image-20251127082425023.png)

![image-20251128083906995](./assets/image-20251128083906995.png)

* 在驱动程序中如何响应用户空间发起的系统调用，比如用户空间调用了 `open()` 函数，驱动中也要有个 `open()` 函数与之对应，。每一个系统调用，在驱动中都有与之对应的一个驱动函数，在Linux内核文件 `include/linux/fs.h `中有一个叫做文件操作集的结构体 `file_operations` ，此结构体就是Linux内核驱动操作函数的集合。

```c
struct file_operations {
	struct module *owner;                    // 指向拥有此结构体的模块指针，用于模块引用计数
	fop_flags_t fop_flags;                   // 文件操作标志位，标识操作集的特性
	loff_t (*llseek) (struct file *, loff_t, int);                          // 调整文件读写位置
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);       // 从文件读取数据到用户空间
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); // 从用户空间写数据到文件
	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);               // 异步读取操作
	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);              // 异步写入操作
	int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *, unsigned int flags); // IO轮询操作
	int (*iterate_shared) (struct file *, struct dir_context *);            // 共享目录遍历
	__poll_t (*poll) (struct file *, struct poll_table_struct *);           // 检查文件描述符是否可读写
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);    // 无锁设备控制命令
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);      // 兼容32位设备的控制命令
	int (*mmap) (struct file *, struct vm_area_struct *);                   // 将文件映射到内存
	int (*open) (struct inode *, struct file *);                            // 打开文件
	int (*flush) (struct file *, fl_owner_t id);                            // 刷新文件，关闭时调用
	int (*release) (struct inode *, struct file *);                         // 释放文件结构体
	int (*fsync) (struct file *, loff_t, loff_t, int datasync);             // 同步文件数据到存储设备
	int (*fasync) (int, struct file *, int);                                // 异步通知设置
	int (*lock) (struct file *, int, struct file_lock *);                   // 文件锁定操作
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); // 获取未映射内存区域
	int (*check_flags)(int);                                                // 检查文件打开标志
	int (*flock) (struct file *, int, struct file_lock *);                  // 文件锁操作
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); // 从管道写入文件
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);  // 从文件读取到管道
	void (*splice_eof)(struct file *file);                                  // 管道读取结束通知
	int (*setlease)(struct file *, int, struct file_lease **, void **);     // 设置文件租约
	long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); // 预分配文件空间
	void (*show_fdinfo)(struct seq_file *m, struct file *f);                // 显示文件描述符信息
#ifndef CONFIG_MMU
	unsigned (*mmap_capabilities)(struct file *);                           // 无MMU时的内存映射能力
#endif
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); // 文件间数据拷贝
	loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags); // 文件范围重映射
	int (*fadvise)(struct file *, loff_t, loff_t, int);                     // 文件访问模式建议
	int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags); // io_uring命令处理
	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *, unsigned int poll_flags); // io_uring轮询操作
	int (*mmap_prepare)(struct vm_area_desc *);                             // 内存映射准备操作
} __randomize_layout;  // 结构体布局随机化，增强安全性
```



# 2. Linux设备号

## 2.1 设备号的组成

Linux 中每个设备都有一个设备号，**设备号由主设备号和次设备号两个部分组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备**，Linux 提供了一个名为 `dev_t` 的数据类型表示设备号，定义在文件 `include/Linux/types.h`

```c
typedef u32 __kernel_dev_t;
typedef __kernel_dev_t		dev_t;
```

其中 `u32` 代表了这个数据结构占32位大小，具体实现就是一个无符号整型：`typedef unsigned int __u32`， 32位中**高12位是主设备号（0~4095），低20位是次设备号**，下面是 `include/linux/kdev_t.h` 文件中提供的一些设备号的一些操作宏：

```c
#define MINORBITS	20 // 表示次设备号的位数一共20位
#define MINORMASK	((1U << MINORBITS) - 1) // 表示次设备号掩码

#define MAJOR(dev)	((unsigned int) ((dev) >> MINORBITS)) // 从dev_t中获取主设备号
#define MINOR(dev)	((unsigned int) ((dev) & MINORMASK)) // 从dev_t中获取次设备号
#define MKDEV(ma,mi)	(((ma) << MINORBITS) | (mi)) // 将给定的主设备号和次设备号的值组合成dev_t类型的设备号
```



## 2.2 设备号的分配

### 2.2.1 静态分配设备号

注册字符设备的时候需要给设备指定一个设备号，这个设备号可以是驱动开发者静态指定的设备号，但是有一些常用的设备号已经被Linux内核开发者分配掉了，具体分配的内容可以查看文档 `Documentation/devices.txt` ，并不是说已经分配掉的设备号就不能用，具体能不能用还得看我们的系统运行过程中有没有用这个主设备号，使用 `cat /proc/devices` 命令可以查看当前系统中已经使用了的设备号



### 2.2.2 动态分配设备号

Linux社区推荐使用动态分配设备号，系统会自动给你一个没有使用的设备号，**可以避免冲突**，卸载驱动的时候释放掉这个设备号即可。

**动态申请和释放设备号：**

```c
/**
 * 动态申请一连串字符设备号，这些设备号的主设备号都一样
 * @param dev: 输出参数，保存分配到的第一个设备编号
 * @param baseminor: 请求的起始次设备号
 * @param count: 需要申请的设备编号数量
 * @param name: 驱动名称（出现在/proc/devices中）
 * @return: 成功返回0，失败返回错误码（负值）
 */
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);

/**
 * 释放一串字符设备编号
 * @param from: 要释放的起始设备编号
 * @param count: 从from开始，要释放的设备编号数量
 */
void unregister_chrdev_region(dev_t from, unsigned count);
```



# 3. 驱动模块的加载和卸载

**驱动程序有两种加载方式：**

1. 将驱动程序编译进内核中，这样在内核启动的时候就会自动运行驱动程序
2. 将驱动程序编译成模块（文件扩展名：.ko），然后用 `insmod` 指令加载驱动模块到内核，用 `rmmod` 指令卸载驱动模块，用 `lsmod` 指令查看当前加载的驱动模块

```c
/**
 * 驱动模块初始化函数宏
 * @param fn: 模块加载时自动执行的初始化函数
 * 
 * 作用：指定模块被 insmod/modprobe 加载时调用的初始化函数
 * 该函数通常用于：
 * - 设备驱动注册
 * - 资源分配
 * - 硬件初始化
 * - 创建/proc或/sys文件
 * 
 * 初始化函数原型：int fn(void)
 * 成功返回0，失败返回错误码（负值）
 */
module_init(fn);

/**
 * 驱动模块退出函数宏
 * @param fn: 模块卸载时自动执行的清理函数
 * 
 * 作用：指定模块被 rmmod 卸载时调用的清理函数
 * 该函数通常用于：
 * - 设备驱动注销
 * - 资源释放
 * - 移除/proc或/sys文件
 * - 硬件去初始化
 * 
 * 清理函数原型：void fn(void)
 */
module_exit(fn);
```



# 4. 文件私有数据

每个硬件设备都会有一些属性，比如设备号，类，设备的各种状态等等，在编写驱动的时候可以将这些设备的属性信息做成一个结构体，编写驱动的 `open() `函数的时候，将这个结构体作为设备文件的**私有数据**加入到设备文件中，然后在 `write()、read()、close()` 函数中直接读取 `private_data` 就可以得到设备私有数据结构体了。

```c
struct my_dev_private_data{
    dev_t devid; // 设备号
    struct cdev cdev; // cdev
    struct class *class; // 类
    struct device *device; // 设备
    __u32 major; // 主设备号
    __u32 minor; // 次设备号
}

struct my_dev_private_data testdev;

static int test_open(struct inode *inode, struct file *filp)
{
    filp->private_data = &testdev; // 绑定私有数据
    return 0;
}
```



# 5. 字符设备注册

## 5.1 cdev结构体

编写字符设备驱动之前需要定义一个 `cdev` 的结构体，这个结构体就表示一个字符设备

```c
/**
 * struct cdev - 内核中的字符设备结构体，内核中用cdev表示一个字符设备，该结构用于管理字符设备驱动程序的内部信息。
 */
struct cdev {
	struct kobject kobj;                 // 内嵌的kobject对象，用于内核对象管理和sysfs接口
	struct module *owner;                // 指向拥有此设备的模块指针，用于模块引用计数管理
	const struct file_operations *ops;   // 文件操作函数集指针，包含设备的所有操作函数
	struct list_head list;               // 链表节点，用于将设备链接到内核全局字符设备链表中
	dev_t dev;                           // 设备号（包含主设备号和次设备号）
	unsigned int count;                  // 从dev开始的连续次设备号的数量（支持驱动管理多个设备实例）
} __randomize_layout;                    // 编译器指令，随机化结构布局，防止内核堆栈攻击
```



## 5.2 cdev_init() 函数

定义好 `cdev` 结构体后需要调用 `cdev_init()` 函数初始化

```c
/**
 * cdev_init - 初始化字符设备结构体
 * @cdev: 要初始化的字符设备结构体指针（不能为NULL）
 * @fops: 设备文件操作函数集指针
 */
void cdev_init(struct cdev *cdev, const struct file_operations *fops);
```



## 5.3 cdev_add() 函数

用于向内核添加字符设备，先使用 `cdev_init()` 函数完成结构体初始化，然后用 `cdev_add()` 函数向内和添加这个字符设备 

```c
/**
 * cdev_add - 向内核系统注册一个字符设备
 * @cdev: 已初始化的字符设备结构体指针
 * @dev: 起始设备号（包含主设备号和起始次设备号）
 * @count: 要注册的连续设备号数量
 *
 * 功能：将cdev添加到内核的字符设备哈希表中，使设备立即可用。成功返回后，用户空间即可通过设备节点访问该设备。
 * 返回：成功返回0，失败返回错误码（负值）
 * 注意：此函数可能失败，调用者必须检查返回值，调用此函数后，设备的操作函数可能被立即调用
 */
int cdev_add(struct cdev *cdev, dev_t dev, unsigned count);
```



## 5.4 cdev_del() 函数

卸载驱动的时候要用 `cdev_del()` 函数从内核中移除相关的字符设备

```c
/**
 * cdev_del - 从内核系统中注销一个字符设备
 * @cdev: 要注销的字符设备结构体指针
 *
 * 功能：将cdev从内核字符设备哈希表中移除，使设备不再可用，删除后，用户空间对该设备的访问将失败。
 * 注意：此函数必须在设备的所有文件都已关闭后才能调用，调用此函数后，cdev结构体可能会被释放或重用
 */
void cdev_del(struct cdev *cdev);
```



## 5.5 创建和删除类

### 5.5.1 创建类

**高版本kernel（Linux 5.x+）**

```c
/**
 * class_create - 创建设备类的函数（新版Linux内核API）
 * @name: 设备类名称字符串，将在/sys/class/下显示
 *
 * 功能：创建一个新的设备类结构体并注册到内核设备模型中
 * 返回值：成功返回struct class指针，失败返回ERR_PTR错误码
 *
 * 注意：
 * 1. Linux 5.0+内核中的新API，简化了参数
 * 2. 不再需要owner参数，所有class由内核统一管理
 * 3. 必须在模块卸载时调用class_destroy()清理资源
 * 4. 在/sys/class/目录下创建对应的类目录
 *
 * 示例：
 * struct class *my_class = class_create("my_device_class");
 */
struct class * __must_check class_create(const char *name);
```

**低版本kernel（Linux 4.x 及之前）**

```c
/**
 * class_create - 创建设备类的宏（旧版Linux内核API）
 * @owner: 拥有此设备类的内核模块指针（通常为THIS_MODULE）
 * @name: 设备类名称字符串，将在/sys/class/下显示
 *
 * 功能：创建一个新的设备类结构体并注册到内核设备模型中
 * 返回值：成功返回struct class指针，失败返回ERR_PTR错误码
 *
 * 注意：
 * 1. 这是一个宏定义，实际调用__class_create()函数
 * 2. 必须在模块卸载时调用class_destroy()清理资源
 * 3. 在/sys/class/目录下创建对应的类目录
 * 4. owner参数用于模块引用计数，防止模块在使用时被卸载
 *
 * 示例：
 * struct class *my_class = class_create(THIS_MODULE, "my_device_class");
 */
#define class_create(owner, name)		\
({						\
	static struct lock_class_key __key;	\
	__class_create(owner, name, &__key);	\
})
```



### 5.5.2 删除类

**卸载驱动程序的时候要删除类**

```c
/**
 * class_destroy - 销毁一个设备类结构
 * @cls: 要销毁的设备类指针，由class_create()创建
 *
 * 功能：从内核设备模型中注销并释放设备类资源
 *       1. 从sysfs中移除对应的/sys/class/目录
 *       2. 释放class结构占用的内存
 *       3. 使该类下的所有设备无法再通过此类访问
 *
 * 注意：
 * 1. 必须在销毁所有属于该类的设备后调用此函数
 * 2. 通常应在模块的退出函数中调用
 * 3. cls参数不能为NULL，但可以是ERR_PTR
 * 4. 如果class_create()失败，不需要调用此函数
 * 5. 调用此函数后，不应再使用cls指针
 */
void class_destroy(const struct class *cls);
```



## 5.6 创建和删除设备节点

**创建和删除必须成对出现**

### 5.6.1 创建设备节点

```c
/**
 * device_create - 创建设备节点并将其注册到sysfs
 * @cls: 设备所属的类指针，由class_create()创建
 * @parent: 父设备指针，用于设备层次结构，可为NULL
 * @devt: 设备号（主设备号+次设备号）
 * @drvdata: 驱动私有数据指针，将存储在device->driver_data中
 * @fmt: 设备名称的格式化字符串（类似printf格式）
 * @...: 格式化字符串的可变参数
 *
 * 功能：
 * 1. 创建设备结构并将其绑定到指定的设备类
 * 2. 在sysfs中创建设备属性文件
 * 3. 通过devtmpfs自动创建设备节点（通常为/dev/xxx）
 * 4. 将驱动私有数据与设备关联
 *
 * 返回值：
 * - 成功：指向新创建设备的指针
 * - 失败：ERR_PTR错误码（可用IS_ERR()检查）
 *
 * 注意：
 * 1. 调用前必须确保cls已通过class_create()成功创建
 * 2. 设备名称将显示在/sys/class/<class_name>/目录下
 * 3. 设备节点通常会在/dev/下自动创建（依赖devtmpfs或udev）
 * 4. 必须与device_destroy()配对使用
 *
 * 示例：
 * // 创建设备节点，名称为mydevice0、mydevice1等
 * struct device *dev1 = device_create(my_class, NULL, 
 *                                     MKDEV(major, 0), 
 *                                     private_data,
 *                                     "mydevice%d", 0);
 * struct device *dev2 = device_create(my_class, NULL,
 *                                     MKDEV(major, 1),
 *                                     private_data, 
 *                                     "mydevice%d", 1);
 */
struct device *
device_create(const struct class *cls, struct device *parent, dev_t devt,
	      void *drvdata, const char *fmt, ...);
```



### 5.6.2 删除设备节点

```c
/**
 * device_destroy - 销毁通过device_create创建的设备
 * @cls: 设备所属的类指针，必须与device_create时的cls一致
 * @devt: 要销毁的设备的设备号（主设备号+次设备号）
 *
 * 功能：
 * 1. 从sysfs中移除设备目录和所有属性文件
 * 2. 删除devtmpfs中的设备节点（如果存在）
 * 3. 释放设备结构占用的内核内存
 * 4. 清除设备与驱动私有数据的关联（dev_set_drvdata(dev, NULL)）
 * 5. 发送KOBJ_REMOVE uevent通知用户空间（如udev）
 *
 * 注意：
 * 1. 必须在模块卸载或设备不再使用时调用
 * 2. 每个device_create()必须对应一个device_destroy()
 * 3. 销毁顺序：先销毁所有设备，再销毁类（class_destroy）
 * 4. devt必须与创建时使用的设备号完全一致
 * 5. cls必须与创建时使用的类指针一致
 *
 * 示例：
 * // 创建设备
 * device_create(my_class, NULL, MKDEV(major, 0), priv, "mydev0");
 * 
 * // 销毁设备
 * device_destroy(my_class, MKDEV(major, 0));
 */
void device_destroy(const struct class *cls, dev_t devt);
```



### 5.6.3 自动创建设备节点

**udev** 和 **mdev** 都是 Linux 系统中的设备管理工具，用于在 `/dev` 目录下动态创建设备节点，但设计目标和应用场景不同：

#### （1）udev

* **名称：**用户空间设备管理器

- **定位**：现代化的、功能完整的设备管理守护进程
- **使用场景**：桌面系统、服务器等完整Linux发行版
- **特点**：
	- 基于 `libudev` 库，功能丰富
	- 支持复杂的设备匹配规则（rules）
	- 支持设备事件处理、权限管理、符号链接创建
	- 可执行外部程序响应设备事件
	- 依赖 systemd 或独立运行
	- 系统资源占用相对较高



#### （2）mdev

* **名称：**迷你设备管理器

- **定位**：嵌入式系统的轻量级设备管理工具
- **使用场景**：嵌入式Linux系统、资源受限环境
- **特点**：
	- Busybox 工具箱的一部分，极其轻量
	- 配置简单，通过 `/etc/mdev.conf` 文件控制
	- 支持热插拔设备管理，在 `/etc/init.d/rcS` 中的 `echo /sbin/mdev > /proc/sys/kernel/hotplug`，开启热插拔设备由 `mdev` 管理
	- 可根据需要创建设备节点
	- 资源占用极少，适合嵌入式环境



# 6. 代码示例

**注：此示例在驱动的 init() 函数中直接注册设备，没有 probe() 函数，没有涉及到设备树，也没有真正的物理设备，他这个驱动是挂载在了虚拟总线上面，路径是 `/sys/devices/virtual/` 所有虚拟设备都在这里**

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#define DRIVER_NAME "my_char_driver" // 驱动名称
#define DEVICE_NAME "mychardev" // 设备名称
#define NUM_DEVICES 2  // 创建2个设备实例
#define MAX_DATA_SIZE 1024 // 数据缓冲区大小

/* 设备私有数据结构 */
struct my_device_data {
    char buffer[MAX_DATA_SIZE];
    size_t data_len;
    struct cdev cdev;
    struct device *device;
    int device_id;
};

/* 模块全局变量 */
static int major_number;
static struct class *driver_class;
static struct my_device_data *devices[NUM_DEVICES];
static dev_t dev_numbers[NUM_DEVICES];

/* 文件操作函数集 */
static int my_open(struct inode *inode, struct file *filp)
{
    struct my_device_data *dev_data;
    
    /* 通过inode获取cdev，再获取私有数据 */
    dev_data = container_of(inode->i_cdev, struct my_device_data, cdev);
    filp->private_data = dev_data;
    
    pr_info("Device %d opened\n", dev_data->device_id);
    return 0;
}

static int my_release(struct inode *inode, struct file *filp)
{
    struct my_device_data *dev_data = filp->private_data;
    
    pr_info("Device %d released\n", dev_data->device_id);
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                      size_t count, loff_t *f_pos)
{
    struct my_device_data *dev_data = filp->private_data;
    ssize_t bytes_to_read;
    
    /* 计算可读取的字节数 */
    bytes_to_read = min(count, dev_data->data_len - *f_pos);
    if (bytes_to_read <= 0)
        return 0;
    
    /* 复制数据到用户空间 */
    if (copy_to_user(buf, dev_data->buffer + *f_pos, bytes_to_read))
        return -EFAULT;
    
    *f_pos += bytes_to_read;
    pr_info("Read %zd bytes from device %d\n", bytes_to_read, dev_data->device_id);
    return bytes_to_read;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                       size_t count, loff_t *f_pos)
{
    struct my_device_data *dev_data = filp->private_data;
    ssize_t bytes_to_write;
    
    /* 确保不超过缓冲区大小 */
    bytes_to_write = min(count, (size_t)MAX_DATA_SIZE);
    
    /* 从用户空间复制数据 */
    if (copy_from_user(dev_data->buffer, buf, bytes_to_write))
        return -EFAULT;
    
    dev_data->data_len = bytes_to_write;
    *f_pos = bytes_to_write;
    pr_info("Wrote %zd bytes to device %d\n", bytes_to_write, dev_data->device_id);
    return bytes_to_write;
}

static loff_t my_llseek(struct file *filp, loff_t offset, int whence)
{
    struct my_device_data *dev_data = filp->private_data;
    loff_t newpos;
    
    switch (whence) {
        case SEEK_SET:
            newpos = offset;
            break;
        case SEEK_CUR:
            newpos = filp->f_pos + offset;
            break;
        case SEEK_END:
            newpos = dev_data->data_len + offset;
            break;
        default:
            return -EINVAL;
    }
    
    if (newpos < 0 || newpos > MAX_DATA_SIZE)
        return -EINVAL;
    
    filp->f_pos = newpos;
    return newpos;
}

static long my_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct my_device_data *dev_data = filp->private_data;
    
    switch (cmd) {
        case 0x100:  // 获取设备ID
            return put_user(dev_data->device_id, (int __user *)arg);
        case 0x101:  // 获取数据长度
            return put_user(dev_data->data_len, (size_t __user *)arg);
        default:
            return -ENOTTY;
    }
}

/* 文件操作结构体 */
static const struct file_operations my_fops = {
    .owner = THIS_MODULE,
    .open = my_open,
    .release = my_release,
    .read = my_read,
    .write = my_write,
    .llseek = my_llseek,
    .unlocked_ioctl = my_ioctl,
};

/* 模块初始化函数 */
static int __init my_driver_init(void)
{
    int i, ret;
    
    pr_info("Initializing %s\n", DRIVER_NAME);
    
    /* 1. 动态分配设备号范围 */
    ret = alloc_chrdev_region(&dev_numbers[0], 0, NUM_DEVICES, DRIVER_NAME);
    if (ret < 0) {
        pr_err("Failed to allocate device numbers\n");
        return ret;
    }
    major_number = MAJOR(dev_numbers[0]);
    pr_info("Allocated major number %d\n", major_number);
    
    /* 2. 创建设备类 */
#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
    driver_class = class_create(THIS_MODULE, DRIVER_NAME);
#else
    driver_class = class_create(DRIVER_NAME);
#endif
    
    if (IS_ERR(driver_class)) {
        pr_err("Failed to create device class\n");
        ret = PTR_ERR(driver_class);
        goto fail_class;
    }
    pr_info("Created device class\n");
    
    /* 3. 初始化每个设备 */
    for (i = 0; i < NUM_DEVICES; i++) {
        /* 分配设备私有数据 */
        devices[i] = kzalloc(sizeof(struct my_device_data), GFP_KERNEL);
        if (!devices[i]) {
            pr_err("Failed to allocate device data for device %d\n", i);
            ret = -ENOMEM;
            goto fail_device;
        }
        
        /* 初始化设备数据 */
        devices[i]->device_id = i;
        snprintf(devices[i]->buffer, MAX_DATA_SIZE, 
                "Initial data for device %d\n", i);
        devices[i]->data_len = strlen(devices[i]->buffer);
        
        /* 4. 初始化cdev结构 */
        cdev_init(&devices[i]->cdev, &my_fops);
        devices[i]->cdev.owner = THIS_MODULE;
        
        /* 5. 将cdev添加到内核 */
        dev_numbers[i] = MKDEV(major_number, i);
        ret = cdev_add(&devices[i]->cdev, dev_numbers[i], 1);
        if (ret < 0) {
            pr_err("Failed to add cdev for device %d\n", i);
            kfree(devices[i]);
            goto fail_device;
        }
        pr_info("Added cdev for device %d (minor %d)\n", i, i);
        
        /* 6. 创建设备节点 */
        devices[i]->device = device_create(driver_class, 
                                          NULL, 
                                          dev_numbers[i], 
                                          devices[i], 
                                          "%s%d", 
                                          DEVICE_NAME, 
                                          i);
        if (IS_ERR(devices[i]->device)) {
            pr_err("Failed to create device node for device %d\n", i);
            cdev_del(&devices[i]->cdev);
            kfree(devices[i]);
            devices[i] = NULL;
            ret = PTR_ERR(devices[i]->device);
            goto fail_device;
        }
        pr_info("Created device node /dev/%s%d\n", DEVICE_NAME, i);
    }
    
    pr_info("%s initialized successfully with %d devices\n", 
            DRIVER_NAME, NUM_DEVICES);
    return 0;

fail_device:
    /* 清理已创建的设备 */
    while (--i >= 0) {
        if (devices[i]) {
            if (!IS_ERR_OR_NULL(devices[i]->device))
                device_destroy(driver_class, dev_numbers[i]);
            cdev_del(&devices[i]->cdev);
            kfree(devices[i]);
        }
    }
    
    class_destroy(driver_class);
    
fail_class:
    unregister_chrdev_region(dev_numbers[0], NUM_DEVICES);
    return ret;
}

/* 模块退出函数 */
static void __exit my_driver_exit(void)
{
    int i;
    
    pr_info("Exiting %s\n", DRIVER_NAME);
    
    /* 按创建顺序的逆序销毁所有设备 */
    for (i = NUM_DEVICES - 1; i >= 0; i--) {
        if (devices[i]) {
            /* 1. 销毁设备节点 */
            device_destroy(driver_class, dev_numbers[i]);
            pr_info("Destroyed device node for device %d\n", i);
            
            /* 2. 从内核删除cdev */
            cdev_del(&devices[i]->cdev);
            pr_info("Deleted cdev for device %d\n", i);
            
            /* 3. 释放设备私有数据 */
            kfree(devices[i]);
            devices[i] = NULL;
            pr_info("Freed device data for device %d\n", i);
        }
    }
    
    /* 4. 销毁设备类 */
    class_destroy(driver_class);
    pr_info("Destroyed device class\n");
    
    /* 5. 注销设备号 */
    unregister_chrdev_region(MKDEV(major_number, 0), NUM_DEVICES);
    pr_info("Unregistered device numbers\n");
    
    pr_info("%s exited successfully\n", DRIVER_NAME);
}

module_init(my_driver_init);
module_exit(my_driver_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("WangZhitai");
MODULE_DESCRIPTION("Complete Character Device Driver Example");

/* 用户空间测试程序示例*/
/*
 * 测试程序：
 * gcc -o test_mychardev test_mychardev.c
 * 
 * #include <stdio.h>
 * #include <fcntl.h>
 * #include <unistd.h>
 * #include <sys/ioctl.h>
 * 
 * int main() {
 *     int fd;
 *     char buf[100];
 *     int dev_id;
 *     
 *     // 测试第一个设备
 *     fd = open("/dev/mychardev0", O_RDWR);
 *     read(fd, buf, sizeof(buf));
 *     printf("Read: %s", buf);
 *     
 *     write(fd, "Hello from user space!", 23);
 *     lseek(fd, 0, SEEK_SET);
 *     read(fd, buf, sizeof(buf));
 *     printf("After write: %s\n", buf);
 *     
 *     ioctl(fd, 0x100, &dev_id);
 *     printf("Device ID: %d\n", dev_id);
 *     
 *     close(fd);
 *     return 0;
 * }
 */
```



