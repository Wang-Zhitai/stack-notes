# 设备树

# 1. 什么是设备树

**设备树**：Device Tree，描述设备树的文件叫做DTS（Device Tree Source）， DTS文件的主要功能就是采用树形结构描述设备的信息，比如CPU数量、内存基地址、IIC设备、SPI设备等，如图所示：

```mermaid
graph LR
    ROOT["根节点 /"] --> SYS["系统级节点"]
    ROOT --> BUS["总线/控制器节点"]
    ROOT --> CHOSEN["chosen节点"]
    ROOT --> ALIASES["aliases节点"]
    
    SYS --> CPU["cpus节点"]
    SYS --> MEMORY["memory节点"]
    
    BUS --> SOC["soc节点"]
    BUS --> PCI["pci节点"]
    BUS --> USB["usb节点"]
    BUS --> I2C0["i2c0节点"]
    BUS --> I2C1["i2c1节点"]
    BUS --> SPI_BUS["spi节点"]
    
    SOC --> INTC["中断控制器"]
    SOC --> CLK["时钟控制器"]
    SOC --> GPIO["GPIO控制器"]
    SOC --> UART["串口控制器"]
    SOC --> ETH["以太网控制器"]
    
    PCI --> PCI_DEV1["PCIe SSD (nvme)"]
    PCI --> PCI_DEV2["GPU显卡 (vga)"]
    
    USB --> USB_CONTROLLER["USB主控"]
    USB_CONTROLLER --> USB_DEV1["USB键盘"]
    USB_CONTROLLER --> USB_DEV2["USB摄像头"]
    
    I2C0 --> I2C0_DEV1["温湿度传感器 (sht3x@44)"]
    I2C0 --> I2C0_DEV2["RTC时钟 (ds1307@68)"]
    I2C0 --> I2C0_DEV3["电源管理IC (mp8860@20)"]
    
    I2C1 --> I2C1_DEV1["音频编解码器 (wm8960@1a)"]
    I2C1 --> I2C1_DEV2["EEPROM存储 (24c02@50)"]
    I2C1 --> I2C1_DEV3["触摸屏控制器 (ft5x06@38)"]
    
    SPI_BUS --> SPI_DEV1["LCD显示屏"]
    SPI_BUS --> SPI_DEV2["FLASH存储器"]
    SPI_BUS --> SPI_DEV3["ADC转换器"]
    
    style ROOT fill:#ffeb3b,stroke:#333,stroke-width:3px
    style SYS fill:#4caf50,stroke:#333
    style BUS fill:#2196f3,stroke:#333
    style CHOSEN fill:#9c27b0,stroke:#333
    style ALIASES fill:#9c27b0,stroke:#333
    style I2C0 fill:#ff9800,stroke:#333
    style I2C1 fill:#ff5722,stroke:#333
    style SPI_BUS fill:#9c27b0,stroke:#333
    style I2C0_DEV1 fill:#e8f5e8,stroke:#333
    style I2C0_DEV2 fill:#e8f5e8,stroke:#333
    style I2C1_DEV1 fill:#fff3e0,stroke:#333
    style I2C1_DEV2 fill:#fff3e0,stroke:#333
    style SPI_DEV1 fill:#e3f2fd,stroke:#333
    style SPI_DEV2 fill:#e3f2fd,stroke:#333
```

一个SOC可以制造出很多不同的主板，但是这些主板都有共同的信息。将共同的信息作为一个通用的文件，这个通用的文件就是 `.dtsi` 文件（类似于C语言中的头文件）。**一般来说 `.dts` 文件描述板级信息（也就是主板上的一些 I2C、SPI、PCI设备等），每一个主板都有一个对应的 DTS 文件。`.dtsi` 文件描述 SOC 信息（也就是芯片有几个CPU、主频是多少，外设控制器信息等），但是也不一定如此，因为 DTS 语法是可以包含的，所以怎么写的都有。**



# 2. dts、dtb、dtbo、dtc

1. **DTS（Device Tree Source）**：
	* 文本格式的源文件，人类可读写，扩展名 `.dts` `.dtsi（包含文件）`
	* 支持 C 预处理器（`#include，#define等`）
2. **DTC(Device Tree Compiler)**：
	* 设备树编译器，将 DTS 转为 DTB
	* 也可以反编译，将 DTB 转为 DTS
3. **DTB（Device Tree Blob）**：
	* 二进制格式的设备树，可以被内核直接解析
4. **DTBO（Device Tree Blob Overlay）**：
	* 增量更新的DTB，用于动态修改设备树

```mermaid
sequenceDiagram
    participant Dev as DTS文件
    participant DTC as DTC编译器
    participant DTB as DTB文件
    participant DTBO as DTBO文件
    participant Boot as U-Boot
    participant Kernel as Linux内核
    participant FS as 文件系统
    
    Note over Dev: 开发阶段
    Dev->>DTC: 编写DTS源文件
    DTC->>DTB: 编译为DTB (dtc -O dtb)
    DTB-->>Dev: 反编译为DTS (dtc -I dtb -O dts)
    DTC->>DTBO: 编译Overlay (dtc -@ -O dtb)
    
    Note over Boot: 启动阶段
    Boot->>DTB: 加载基础DTB到内存
    Boot->>DTBO: 可选：加载overlay
    Boot->>Kernel: 传递DTB地址给内核
    
    Note over Kernel: 内核初始化
    Kernel->>Kernel: 解析DTB为device_node结构
    Kernel->>Kernel: 合并DTBO（如果存在）
    
    Note over Kernel: 运行时
    Kernel->>FS: 挂载文件系统后
    FS->>Kernel: 动态加载DTBO (fdtoverlay)
    Kernel->>Kernel: 动态修改设备树
```



# 3. DTS语法

## 3.1 .dtsi头文件

* 和 C 语言一样，设备树也支持头文件，设备树的头文件扩展名为 `.dtsi`。
* 使用 `#include "*******.dtsi"` 或者 `#include "*******.dts"` 或者 `#include "*******.h"`引入头文件
* 一般来说 `.dtsi` 文件描述的是SOC的信息，或者一些比较通用的信息，而 `.dts` 文件描述的是板级信息，但是也不一定如此，因为 DTS 语法是可以包含的，所以怎么写的都有

```c
// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
 *
 */

/dts-v1/;

#include "rk3566-lubancat-1.dtsi"
#include "rk3566-android.dtsi"

// #include "rk3566-lubancat-hdmi.dtsi" //HDMI输出
// #include "rk3566-lubancat-dsi0-7.0-1024x600.dtsi" //野火7寸 600P
// #include "rk3566-lubancat-dsi0-10.1-800x1280.dtsi" //野火10.1寸 800P
#include "rk3566-lubancat-dsi0-ebf410125_1080p.dtsi" //野火5.5寸 1080P
// #include "rk3566-lubancat-dsi0-rpi.dtsi" //树莓派 5寸 800x480

// RTC
// #include "rk356x-lubancat-i2c3-m0-rtc.dtsi"
// #include "rk356x-lubancat-i2c3-m1-rtc.dtsi"
// #include "rk356x-lubancat-i2c5-m0-rtc.dtsi"
// #include "rk356x-lubancat-rk809-rtc.dtsi"

/ {
	model = "EmbedFire LubanCat-1";
	compatible = "embedfire,lubancat-1", "rockchip,rk3566";
};
```



## 3.2 设备节点

1. 设备树采用树形结构描述设备，每一个节点都代表了一个设备，叫做设备节点，每个节点都通过一些属性信息来描述设备信息，属性就是一个键值对。
2. 每个设备树只有一个根节点

```c
/ {
    /* ============ chosen节点 ============
     * chosen节点用于传递固件到内核的运行时配置参数
     * 它不是实际的硬件设备，而是配置容器
     */
    chosen: chosen {
        /* bootargs: 内核启动参数
         * - earlycon=uart8250,mmio32,0xfe660000: 早期控制台使用UART8250兼容设备
         *   内存映射I/O，32位访问，基地址0xfe660000
         * - console=ttyFIQ0: 系统控制台设置为ttyFIQ0设备
         */
        bootargs = "earlycon=uart8250,mmio32,0xfe660000 console=ttyFIQ0";
    };

    /* ============ aliases节点 ============
     * 为设备节点创建短名称（别名），方便通过短名引用设备
     * 格式: alias-name = &node-label;
     */
    aliases {
        mmc0 = &sdmmc0;      /* SD/MMC控制器0的别名 */
        mmc1 = &sdmmc1;      /* SD/MMC控制器1的别名 */
        mmc2 = &sdhci;       /* SDHCI控制器的别名 */
        mmc3 = &sdmmc2;      /* SD/MMC控制器2的别名 */
        ethernet1 = &gmac1;  /* 以太网控制器1的别名 */
        // 注: &sdmmc0, &sdmmc1等需要在设备树其他地方定义
    };

    /* ============ FIQ调试器节点 ============
     * FIQ(Fast Interrupt Request)调试器，用于系统调试
     * 这个节点没有单元地址，因为它不是一个内存映射设备
     */
    fiq-debugger {
        compatible = "rockchip,fiq-debugger";  /* 驱动匹配字符串 */
        rockchip,serial-id = <2>;              /* 使用的串口ID: 2 */
        rockchip,wake-irq = <0>;               /* 唤醒中断: 0表示禁用 */
        
        /* 如果启用，UART使用IRQ代替FIQ */
        rockchip,irq-mode-enable = <1>;        /* 1=启用IRQ模式, 0=使用FIQ */
        
        rockchip,baudrate = <1500000>;         /* 波特率: 仅支持115200和1500000 */
        
        /* 中断定义:
         * - GIC_SPI: SPI类型中断(共享外设中断)
         * - 252: 中断号
         * - IRQ_TYPE_LEVEL_LOW: 低电平触发
         */
        interrupts = <GIC_SPI 252 IRQ_TYPE_LEVEL_LOW>;
        
        /* 引脚控制 */
        pinctrl-names = "default";            /* 引脚状态名称 */
        pinctrl-0 = <&uart2m0_xfer>;          /* 使用uart2m0_xfer引脚配置 */
        
        status = "okay";                       /* 设备状态: okay=启用, disabled=禁用 */
    };

    /* ============ 调试子系统节点 ============
     * 调试控制器节点，标签为debug
     * 节点名: debug, 单元地址: 0xfd904000
     */
    debug: debug@fd904000 {
        compatible = "rockchip,debug";        /* Rockchip调试控制器 */
        
        /* 寄存器映射定义: 4个连续的1KB内存区域
         * 格式: <地址高位 地址低位 大小高位 大小低位>
         * 这里使用64位地址，高位为0
         * 1. 0xfd904000-0xfd904fff (1KB)
         * 2. 0xfd905000-0xfd905fff (1KB)
         * 3. 0xfd906000-0xfd906fff (1KB)
         * 4. 0xfd907000-0xfd907fff (1KB)
         */
        reg = <0x0 0xfd904000 0x0 0x1000>,
              <0x0 0xfd905000 0x0 0x1000>,
              <0x0 0xfd906000 0x0 0x1000>,
              <0x0 0xfd907000 0x0 0x1000>;
        
        /* 注意: 这个节点缺少status属性，通常应该有status = "okay"或"disabled" */
        /* 可能在其他地方通过&debug引用并添加属性 */
    };
};
```



### 3.2.1 节点命名

**节点命名**：label: node-name@unit-address

| 组件         | 语法           | 必需性   | 描述                                                 |
| :----------- | :------------- | :------- | :--------------------------------------------------- |
| **节点标签** | `label:`       | 可选     | 用于引用节点的标识符，可以通过 `&label` 直接访问节点 |
| **节点名**   | `node-name`    | 必需     | 描述节点功能的名称                                   |
| **分隔符**   | `@`            | 条件必需 | 分隔节点名和地址                                     |
| **单元地址** | `unit-address` | 可选     | 节点在总线上的地址                                   |
| **内容边界** | `{ }`          | 必需     | 节点属性的开始和结束                                 |



### 3.2.2 节点属性常用表示方法

每个节点都有不同的属性，不同的属性又有不同的内容，属性都是一个键值对，值可以是任意的，常用以下几种方式表示属性：

#### （1）字符串

```c
// 设置compatible属性的值为字符串“rockchip,debug”
compatible = "rockchip,debug";
```

#### （2）32位无符号整形

```c
// reg可以设置成一个值，也可以像示例一样设成一组值
reg = <0x0 0xfd90c000 0x0 0x1000>,
	  <0x0 0xfd90d000 0x0 0x1000>,
	  <0x0 0xfd90e000 0x0 0x1000>,
	  <0x0 0xfd90f000 0x0 0x1000>;
```

#### （3）字符串列表

```c
// 属性值也可以为字符串列表，之间用 "," 分开
compatible = "arm,cortex-a55-pmu", "arm,armv8-pmuv3";
```



## 3.3 标准属性

每个设备节点都是具体的设备，都有很多的属性组成，不同的设备需要的属性不同，用户可以自定义属性。也有很多的标准属性:

### 3.3.1 compatible属性

**`compatible` 也叫做“兼容性”属性，它的值是一个字符串列表，它用于将驱动和设备绑定起来**，字符串列表用于选择设备所使用的驱动程序，一般驱动程序文件都会有一个 `OF` 匹配表，匹配表保存这些 `compatible` 值如果设备节点的 `compatible` 属性和 `OF` 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动

```c
// 一般来说格式如下，前面的是制造商的名字，后面是模块对应的驱动名字
compatible = "rockchip,remotectl-pwm";
```



### 3.3.2 model属性

**`model` 属性，是一个字符串，一般用于描述设备模块信息的，比如名字等等：**

```c
model = "EmbedFire LubanCat-1";
```



### 3.3.3 status属性

**`status` 属性和设备状态相关，他的值是一个字符串，存放的是设备的状态信息：**

| 值               | 含义     | 内核行为                                                     |
| :--------------- | :------- | :----------------------------------------------------------- |
| **`"okay"`**     | 设备启用 | 内核会初始化和使用该设备                                     |
| **`"disabled"`** | 设备禁用 | 内核会忽略该设备，但是如果是热插拔设备，未来是可以变成启用的 |
| **`"reserved"`** | 设备保留 | 设备被保留给其他用途（如安全世界）                           |
| **`"fail"`**     | 设备故障 | 设备存在但无法正常工作，设备检测到了一系列错误               |
| **`"fail-sss"`** | 特定故障 | 带原因代码的故障状态,后面的 sss 部分是检测到的错误内容       |



### 3.3.4 #address-cells和#size-cells属性

* **这两个属性的值都是32位无符号整形，这两个属性`可以用在任何拥有子节点的设备中，用于描述子节点的地址信息`**
* **`#address-cells` 属性决定了字节点 reg 属性中地址信息所占用的字长（一个字长是一个32位数，如果这个值是2代表用两个32位数表示一个地址信息）**
* **`#size-cells` 属性值决定了子节点 reg 属性中长度信息所占的字长（一个字长是一个32位数，如果这个值是2代表用两个32位数表示一个地址信息）**

```c
// address+length 组合表示一个地址范围，address 是起始地址，length 是地址长度
reg = <address1 length1 address2 length2 address3 length3.......>
```

**举例：**

```c
cpus {
    #address-cells = <2>;          // <2>表示：地址用2个cell表示(64位)
    #size-cells = <0>;             // <0>表示：地址没有大小字段

    cpu1: cpu@100 {                // CPU1节点，标签cpu1，节点名cpu@100
        device_type = "cpu";       // 设备类型：CPU
        compatible = "arm,cortex-a55"; // 兼容ARM Cortex-A55内核
        reg = <0x0 0x100>;         // CPU标识：高位0，低位0x100（可能是特殊的CPU编号）
        enable-method = "psci";    // 使用PSCI接口启用CPU
        clocks = <&scmi_clk 0>;    // 时钟来自scmi_clk节点的第0个时钟
        operating-points-v2 = <&cpu0_opp_table>; // 引用频率电压表
        cpu-idle-states = <&CPU_SLEEP>; // 引用CPU空闲状态定义
    };
};

aips3: aips-bus@02200000 {        // AIPS总线3，标签aips3，基地址0x02200000
    compatible = "fsl,aip-bus", "simple-bus"; // 表示飞思卡尔公司生产，兼容AIPS总线和简单总线驱动
    #address-cells = <1>;          // 子节点地址用1个cell(32位)
    #size-cells = <1>;             // 子节点大小用1个cell(32位)
    
    dcp: dcp@02280000 {            // 数据协处理器，标签dcp，地址0x02280000
        compatible = "fsl,imx6sl-dcp"; // 飞思卡尔公司生产，兼容i.MX6SL-DCP驱动
        reg = <0x02280000 0x4000>; // 寄存器：基地址0x02280000，大小0x4000(16KB)
    };
};
```



### 3.3.5 reg属性

**`reg` 属性的值一般是<地址,长度>对，一般用于描述设备地址空间资源信息（比如某个外设的寄存器地址信息范围）**

```c
/{
	compatible = "rockchip,rk3568";            // 平台兼容性标识
	interrupt-parent = <&gic>;                 // 默认中断控制器为GIC
	#address-cells = <2>;                      // 地址用2个32位数cell（64位）
	#size-cells = <2>;                         // 大小用2个32位数cell（64位）
    
	uart0: serial@fdd50000 {                   // UART0串口，标签uart0，基地址0xfdd50000
			compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";  // 兼容性字符串
			reg = <0x0 0xfdd50000 0x0 0x100>;  // 寄存器：64位地址0xfdd50000，大小0x100(256字节)
			interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;  // GIC SPI中断116，高电平触发
			clocks = <&pmucru SCLK_UART0>, <&pmucru PCLK_UART0>;  // 时钟源：波特率时钟和APB总线时钟
			clock-names = "baudclk", "apb_pclk";  // 时钟名称标识
			reg-shift = <2>;                    // 寄存器地址偏移2位（即寄存器间距为4字节）
			reg-io-width = <4>;                 // 寄存器IO宽度为4字节（32位）
			dmas = <&dmac0 0>, <&dmac0 1>;      // DMA通道：发送通道0，接收通道1
			pinctrl-names = "default";          // 引脚控制状态名称
			pinctrl-0 = <&uart0_xfer>;          // 默认引脚配置引用
			status = "disabled";                // 默认禁用，板级文件中启用
	};
}

/*
* reg = <0x0 0xfdd50000 0x0 0x100>;
*      │     │           │     │
*      │     │           │     └── 长度低位：0x100 = 256字节
*      │     │           └── 长度高位：0x0（32位系统通常为0）
*      │     └── 地址低位：0xfdd50000（物理地址低32位）
*      └── 地址高位：0x0（物理地址高32位，32位系统为0）
* 
* 实际物理地址：0x00000000 fdd50000（64位地址）
* 地址范围：0xfdd50000 - 0xfdd500ff（256字节）
* 每个寄存器占用4字节（reg-io-width=4），共有64个寄存器位置
* 寄存器访问地址 = 基地址 + 寄存器编号 × 4（因为reg-shift=2，即2²=4）
*/
```



### 3.3.6 ranges属性

* **`ranges` 属性可以为空，或者按照 `<child-bus-address parent-bus-address length>` 格式编写的数字矩阵，是一个地址映射/转换表，ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成**
* **`child-bus-address`：子总线地址空间的物理地址由父节点的 #address-cells 决定此物理地址所占用的字长**
* **`parent-bus-address`：父总线地址空间的物理地址由父节点的 #address-cells 决定此物理地址所占用的字长**
* **`length`：子地址空间的长度由父节点的 #size-cells 决定此地址空间所占用的字长**
* **如果 `ranges` 属性为空说明此地址空间和副地址空间完全相同不需要进行地址转换**

**举例：**

```c
/ {
	compatible = "rockchip,rk3568";
	interrupt-parent = <&gic>;
	#address-cells = <2>;  // 根节点地址用2个cell（64位系统）
	#size-cells = <2>;     // 根节点大小用2个cell（64位系统）

	sram: sram@fdcc0000 {  // SRAM控制器节点，标签sram，物理地址0xfdcc0000
		compatible = "mmio-sram";
		// SRAM物理地址范围：0xfdcc0000-0xfdccafff (45KB)
		// 格式：<地址高位 地址低位 大小高位 大小低位>
		// 地址：0x0(fdcc0000高位) 0xfdcc0000(低位) = 0x00000000_fdcc0000
		// 大小：0x0(大小高位) 0xb000(大小低位) = 45KB
		reg = <0x0 0xfdcc0000 0x0 0xb000>;

		#address-cells = <1>;  // 子节点地址用1个cell（32位相对地址）
		#size-cells = <1>;     // 子节点大小用1个cell（32位）
		
		// ranges：子地址到父地址的映射
		// 格式：<子地址 父地址高位 父地址低位 长度高位 长度低位>
		// 这里使用Rockchip简写：<子地址 父地址低位 长度低位>
		// 隐含条件：父地址高位=0，长度高位=0（32位系统）
		// 完整应为：<0x0 0x0 0xfdcc0000 0x0 0xb000>
		// 简写为：<0x0 0x0 0xfdcc0000 0xb000>
		ranges = <0x0 0x0 0xfdcc0000 0xb000>;
		// 映射含义：子地址0x0对应物理地址0xfdcc0000，映射长度0xb000

		/* start address and size should be 4k algin */
		rkvdec_sram: rkvdec-sram@0 {  // 视频解码SRAM分区，子地址0x0
			// 子节点地址：相对偏移0x0，大小0xb000
			// 对应物理地址：0xfdcc0000 + 0x0 = 0xfdcc0000
			reg = <0x0 0xb000>;
		};
	};
}
```



# 4. 匹配机制

Linux 内核根据设备树 compatible 属性找到对应驱动函数的过程是一个**设备-驱动匹配**的过程，详细分析调用链：

```c
// 设备树解析阶段
start_kernel
  └── setup_arch
        └── unflatten_device_tree
              └── __unflatten_device_tree
                    └── 将DTB解析为struct device_node
    
// 平台设备创建阶段
of_platform_populate
  ├── of_platform_device_create_pdata
  │     ├── platform_device_alloc
  │     ├── platform_device_add_data
  │     └── platform_device_add
  │           └── device_add
  └── of_platform_bus_create
    
// 驱动匹配阶段
device_add
  └── bus_probe_device
        └── device_initial_probe
              └── __device_attach
                    └── __device_attach_driver
                          ├── driver_match_device  // 检查驱动和设备是否匹配
                          │     └── of_driver_match_device  // OF风格的匹配
                          │           └── of_match_device
                          │                 └── of_match_node
                          │                       └── __of_match_node
                          │                             ├── of_device_is_compatible  // 检查compatible
                          │                             └── score = of_match_compatible
                          └── 如果匹配成功 → driver_probe_device
                                └── really_probe
                                      └── drv->probe(dev)  // 调用驱动的probe函数
```



# 5. 向节点追加或者修改内容

现在有个设备树头文件 `rk3506.dtsi` ，里面有一个 I2C 控制器的节点：

```c
i2c0: i2c@ff040000 {
		compatible = "rockchip,rk3506-i2c", "rockchip,rk3399-i2c";
		reg = <0xff040000 0x1000>;
		interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>;
		#address-cells = <1>;
		#size-cells = <0>;
		clocks = <&cru CLK_I2C0>, <&cru PCLK_I2C0>;
		clock-names = "i2c", "pclk";
		status = "disabled";
	};
```

如果我想在 I2C 下面挂一个MPU6050的设备，我可以直接在这个节点里添加并编写节点，但是这样的话我就把这个头文件修改掉了，别的使用这个设备树头文件但是并没有挂载MPU6050的板子就没法工作了，我们需要能够在别的文件中也可以实现对于节点的添加和修改，我们可以用引用的方式来实现,在别的文件内**通过 `&label` 来访问节点**：

```c
&i2c0 {
	/* 要添加或者修改的内容 */
};
```



# 6. 设备树在系统中的体现

Linux内核在启动的时候会解析 DTB 文件，然后在 `/proc/device-tree` 目录下生成相应的设备树节点文件

![image-20251209152656538](./assets/image-20251209152656538.png)

# 7. 特殊节点

## 7.1 aliases子节点

### （1）基本概念

`aliases` 节点为设备树中的其他节点提供**短名称（别名）**，方便通过简短的名字引用复杂路径的设备节点。



### （2）语法格式

```c
/ {
    aliases {
        serial0 = &uart1;      // 串口0 别名指向 uart1
        serial1 = &uart2;      // 串口1 别名指向 uart2
        ethernet0 = &eth0;     // 以太网0 别名指向 eth0
        mmc0 = &sdhci0;        // MMC/SD卡0 别名指向 sdhc0
        led0 = &user_led0;     // led0 别名指向 user_led0
    };
};
```



### （3）主要用途

1. **简化设备引用**

```c
// 使用别名访问
struct device_node *np = of_find_node_by_alias(of_root, "serial0");
// 等价于直接访问完整路径
struct device_node *np = of_find_node_by_path("/soc/serial@12340000");
```

2. **U-Boot/bootloader 使用**

```c
# U-Boot 中使用别名设置环境变量
setenv bootargs console=${serial0},115200

# 访问MMC设备
mmc dev ${mmc0}
```

3. **内核设备编号固定**

```c
// 确保串口总是 ttyS0, ttyS1 顺序
aliases {
    serial0 = &uart0;  // 对应 /dev/ttyS0
    serial1 = &uart1;  // 对应 /dev/ttyS1
    serial2 = &uart2;  // 对应 /dev/ttyS2
};
```



### （4）系统预定义的标准别名

| 别名前缀   | 用途        | 示例                     |
| :--------- | :---------- | :----------------------- |
| `serial`   | 串口设备    | `serial0`, `serial1`     |
| `ethernet` | 以太网设备  | `ethernet0`, `ethernet1` |
| `mmc`      | MMC/SD 设备 | `mmc0`, `mmc1`           |
| `spi`      | SPI 控制器  | `spi0`, `spi1`           |
| `i2c`      | I2C 控制器  | `i2c0`, `i2c1`           |
| `usb`      | USB 控制器  | `usb0`, `usb1`           |
| `pci`      | PCI 控制器  | `pci0`, `pci1`           |



## 7.2 chosen子节点

### （1）基本概念

`chosen` 节点**不描述硬件**，而是传递**运行时参数**，通常由 U-Boot 动态修改，用于向内核传递启动信息，重点是 bootargs 参数，U-Boot 在引导 kernel 启动的时候会将 bootargs 的值传递给 kernel ， bootargs 会作为 kernel 的命令行参数。

### （2）典型结构

```c
// 这是正点原子的RK3506b开发板的一个chosen节点，启动后也可以在 /sys/firmware/devicetree/base/chosen 目录下看到
/ {
        chosen {
                bootargs = "earlycon=uart8250,mmio32,0xff0a0000 console=ttyFIQ0 ubi.mtd=5 root=ubi0:rootfs rw rootfstype=ubifs rootwait snd_aloop.index=7 snd_aloop.use_raw_jiffies=1 storagemedia=mtd androidboot.storagemedia=mtd androidboot.mode=normal";
        };
};
```



### （3）关键属性详解

1. **bootargs** - 内核启动参数

```c
chosen {
    // 控制台、根文件系统、其他内核参数
    bootargs = "console=ttyS0,115200 earlycon root=/dev/mmcblk0p2 rw rootwait panic=5";
};
```

常用参数：

- `console=`：指定控制台设备
- `root=`：根文件系统设备
- `init=`：初始化程序
- `loglevel=`：内核日志级别
- `mem=`：内存大小

2. stdout-path / stdin-path - 标准输入输出

```c
chosen {
    stdout-path = "serial0:115200n8";           // 字符串形式
    stdout-path = &uart0;                       // 引用节点形式
    stdin-path = &uart0;
};
```

2. initrd 相关 - 初始 RAM 磁盘

```c
chosen {
    linux,initrd-start = <0x82000000>;         // initrd 起始地址
    linux,initrd-end = <0x82800000>;           // initrd 结束地址
};
```

3. 其他常见属性

```c
chosen {
    #address-cells = <1>;                      // 地址单元数
    #size-cells = <1>;                         // 大小单元数
    
    // 内存保留区域
    linux,usable-memory-range = <0x0 0x40000000>;
    
    // 帧缓冲区配置
    linux,frame-buffer = <0x88000000 0x800000>;
    
    // rng种子（随机数）
    rng-seed = <0x12345678 0x9abcdef0>;
};
```



# 8. 绑定信息文档

设备树是用来描述板子上的设备信息的，不同的设备信息不同，反映到设备树中就是属性不同。**那么我们在设备树中添加一个硬件对应的节点的时候，该如何添加节点，从哪里查阅相关的说明呢？**

**在Linux内核源码中有详细的TXT文档描述如何添加节点**，这些TXT文档叫做**绑定文档**，路径在Linux源码目录的 **/Documentation/devicetree/bindings** 有些芯片厂商不提供这个，那么也可以看他们提供的参考的设备树来修改



# 9. 设备树常用OF操作函数

设备树描述了设备的详细信息，这些信息有很多数据类型的，在编写驱动的时候想要需要获取到这些信息，可以使用 **`OF (Open Firmware) 函数`**，这些函数的定义都在 `include /linux/of.h` 中，这些 OF 函数使得驱动程序能够**独立于硬件平台**，通过设备树动态获取配置信息，大大提高了驱动的可移植性和可维护性。

## 9.1 节点操作函数

### （1）查找节点函数

```c
// 通过路径查找节点
struct device_node *of_find_node_by_path(const char *path);
// 示例：of_find_node_by_path("/soc/i2c@12340000")

// 通过名称查找节点
struct device_node *of_find_node_by_name(struct device_node *from,
                                        const char *name);

// 通过设备类型查找
struct device_node *of_find_node_by_type(struct device_node *from,
                                        const char *type);

// 通过 compatible 属性查找
struct device_node *of_find_compatible_node(struct device_node *from,
                                           const char *type,
                                           const char *compatible);

// 通过别名查找
struct device_node *of_find_node_by_alias(struct device_node *from,
                                         const char *alias);
```

### （2）节点遍历函数

```c
// 遍历子节点
#define for_each_child_of_node(parent, child) \
    for (child = of_get_next_child(parent, NULL); child != NULL; \
         child = of_get_next_child(parent, child))

// 获取第一个子节点
struct device_node *of_get_next_child(const struct device_node *node,
                                     struct device_node *prev);

// 获取父节点
struct device_node *of_get_parent(const struct device_node *node);
```



## 9.2 属性读取函数

### （1）基本属性读取

```c
// 查找属性
struct property *of_find_property(const struct device_node *np,
                                 const char *name, int *lenp);

// 检查属性是否存在
bool of_property_read_bool(const struct device_node *np, const char *propname);

// 读取字符串属性
int of_property_read_string(const struct device_node *np, const char *propname,
                           const char **out_string);

// 读取字符串数组
int of_property_read_string_array(const struct device_node *np,
                                 const char *propname,
                                 const char **out_strs, size_t sz);
```

### （2）数值属性读取

```c
// 读取单个32位整数
static inline int of_property_read_u32(const struct device_node *np,
                                      const char *propname, u32 *out_value);

// 读取64位整数
int of_property_read_u64(const struct device_node *np,
                        const char *propname, u64 *out_value);

// 读取8/16位整数
int of_property_read_u8/u16(const struct device_node *np,
                           const char *propname, u8/u16 *out_value);

// 读取数组
int of_property_read_u32_array(const struct device_node *np,
                              const char *propname,
                              u32 *out_values, size_t sz);

// 读取变长数组（自动分配内存）
int of_property_count_elems_of_size(const struct device_node *np,
                                   const char *propname, int elem_size);
```



## 9.3 地址和中断相关函数

### （1）地址转换

```c
// 获取地址单元数
int of_n_addr_cells(struct device_node *np);

// 获取大小单元数
int of_n_size_cells(struct device_node *np);

// 获取reg属性并映射地址
void __iomem *of_iomap(struct device_node *np, int index);

// 获取reg属性
int of_address_to_resource(struct device_node *np, int index,
                          struct resource *r);

// 获取内存地址
u64 of_translate_address(struct device_node *np, const __be32 *addr);
```

### （2）中断相关

```c
// 获取中断号
unsigned int irq_of_parse_and_map(struct device_node *np, int index);

// 解析中断属性
int of_irq_get(struct device_node *np, int index);

// 获取中断数量
int of_irq_count(struct device_node *np);

// 获取中断父节点
struct device_node *of_irq_find_parent(struct device_node *child);
```



## 9.4 GPIO、pinctrl、时钟等专用函数

### （1）GPIO函数

```c
#include <linux/of_gpio.h>

// 获取GPIO编号
int of_get_named_gpio(struct device_node *np, const char *propname, int index);

// 获取GPIO数量
int of_gpio_named_count(struct device_node *np, const char *propname);

// 获取所有GPIO
int of_gpio_count(struct device_node *np);
```

### （2）pinctrl

```c
#include <linux/pinctrl/consumer.h>

// 获取pinctrl状态
struct pinctrl *of_pinctrl_get(struct device_node *np);
```

### （3）时钟函数

```c
#include <linux/clk.h>

// 获取时钟
struct clk *of_clk_get(struct device_node *np, int index);

// 通过名称获取时钟
struct clk *of_clk_get_by_name(struct device_node *np, const char *name);

// 获取时钟频率
int of_clk_get_parent_name(struct device_node *np, int index, const char **name);
```

### （4）复位函数

```c
#include <linux/reset-controller.h>

// 获取复位控制器
struct reset_control *of_reset_control_get(struct device_node *np,const char *id);
```



## 9.5 使用示例

```c
#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/of_platform.h>

static int my_device_probe(struct platform_device *pdev)
{
    struct device *dev = &pdev->dev;
    struct device_node *np = dev->of_node;
    struct my_device_data *data;
    int ret;
    
    // 分配驱动数据
    data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
    
    // 1. 获取寄存器基地址
    data->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    data->base = devm_ioremap_resource(dev, data->res);
    
    // 2. 获取中断
    data->irq = platform_get_irq(pdev, 0);
    
    // 3. 从设备树读取配置
    of_property_read_u32(np, "clock-frequency", &data->clk_freq);
    of_property_read_u32(np, "fifo-depth", &data->fifo_depth);
    
    // 4. 获取 GPIO
    data->reset_gpio = of_get_named_gpio(np, "reset-gpios", 0);
    if (gpio_is_valid(data->reset_gpio)) {
        devm_gpio_request(dev, data->reset_gpio, "reset");
        gpio_direction_output(data->reset_gpio, 1);
    }
    
    // 5. 获取时钟
    data->clk = devm_clk_get(dev, NULL);
    if (!IS_ERR(data->clk)) {
        clk_prepare_enable(data->clk);
    }
    
    // 6. 检查特性标志
    if (of_property_read_bool(np, "use-dma")) {
        data->use_dma = true;
    }
    
    // 7. 获取自定义属性
    const char *mode;
    if (!of_property_read_string(np, "operating-mode", &mode)) {
        if (!strcmp(mode, "high-performance"))
            data->mode = MODE_HIGH_PERF;
        else if (!strcmp(mode, "low-power"))
            data->mode = MODE_LOW_POWER;
    }
    
    return 0;
}

static const struct of_device_id my_device_of_match[] = {
    { .compatible = "vendor,my-device" },
    { .compatible = "vendor,my-device-v2" },
    {},
};
MODULE_DEVICE_TABLE(of, my_device_of_match);
```



# 10. 编译与反编译设备树

**反编译设备树的用处：**

1. 有的设备树用了很多引用头文件，一个节点在好多文件中都引用了，但是编译的时候这些节点都会合并，通过反编译设备树，可以清晰的看到整个设备树的结构
2. 可以将很多的 .dtsi 和 .dts 编译后产生的 DTB 反编译成一整个 DTS 文件，便于排查问题

```bash
# 通过使用一下指令可以将设备树反编译成DTS源文件，将 xxx.dtb 还有 xxx.dts 替换成自己使用的文件即可
dtc -I dtb -O dts xxx.dtb -o xxx.dts
```



# 11. 设备树插件

**设备树插件（Device Tree Overlay）允许在运行时动态修改设备树的内容**，以便于添加修改或者删除设备节点和属性，设备树插件可以通过加载和解析设备树文件，将其合并到现有的设备树中，以实现对设备树的动态修改
