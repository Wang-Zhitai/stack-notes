# 头文件
```c
#include "task.h"
```


# 一、创建任务

## （1）延迟函数

**vTaskDelay()：** 从执行vTaskDelay()函数开始阻塞，直到指定延时的时间结束。

* 它的工作方式是让当前任务进入阻塞状态，等待指定的时间过去。在这段时间内，调度器可以切换到其他就绪任务去执行。
```c
void LED1Task(void * pvParameters) {
	while(1){ 
		LED1_Turn(); 
		vTaskDelay(500);
	} 
}
```
**xTaskDelayUntil()：** 将整个任务的运行周期视为一个整体，适用于需要以固定频率定期执行的任务,比如可以在通讯协议处理上使用。
* 这个函数会根据系统节拍定时器来计算下一次任务应该被唤醒的时间，从而确保任务能够按照固定的周期执行。
- 首先，需要包含必要的头文件：
```c
#include "task.h"
```
* 定义一个全局变量来记录上次唤醒时间：
```c
static TickType_t xLastWakeTime;
```
- 定义任务函数：
```c
void vBlinkTask(void *pvParameters)
{
    // 初始化LED引脚（假设为这里写的驱动函数是GPIO_Init）
    GPIO_Init()
    //获取当前系统时间
    xLastWakeTime = xTaskGetTickCount();
    //定义一个只读的周期
    const TickType_t xFrequency = pdMS_TO_TICKS(500);
    while(1)
    {
        // 点亮LED
        gpio_set_level(GPIO_NUM_2, 1);
        // 等待直到下一个周期
        xTaskDelayUntil(&xLastWakeTime, xFrequency);
        // 熄灭LED
        gpio_set_level(GPIO_NUM_2, 0);
        // 再次等待直到下一个周期
        xTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}
```
- 在main函数中创建任务：
```c
void app_main()
{
	xTaskCreate(vBlinkTask, "BlinkTask", 1024, NULL, 1, NULL);
    vTaskStartScheduler();
}
```
* 当任务被唤醒后，熄灭 LED，然后再次调用xTaskDelayUntil等待下一个周期，这样就实现了 LED 以 500ms 为周期闪烁的功能。
## （2）创建任务

| API函数             | 描述                         |
| ----------------- | -------------------------- |
| TaskHandle_t      | 任务句柄、任务控制块变量类型             |
| xTaskCreate       | 动态创建一项新任务 并将其添加到准备运行的任务列表中 |
| xTaskCreateStatic | 静态创建一项新任务 并将其添加到准备运行的任务列表中 |
| vTaskDelete       | 删除任务                       |
	**动态创建任务 ：** 任务的任务控制块以及任务的栈空间所需的内存，均由 FreeRTOS 从FreeRTOS 管理的堆中分配。
	**静态创建任务 ：** 任务的任务控制块以及任务的栈空间所需的内存，需用户分配提供。


**动态内存创建:**

* 配置文件（FreeRTOS.h）：
```c
将宏configSUPPORT_DYNAMIC_ALLOCATION 配置为 1。
```
* 函数说明
```c
BaseType_t xTaskCreate( 
	TaskFunction_t pvTaskCode, // 指向要执行的任务函数的指针
	const char * const pcName, //任务名字，最大长度configMAX_TASK_NAME_LEN
	const configSTACK_DEPTH_TYPE uxStackDepth, //任务堆栈大小
	void *pvParameters, //传递给任务函数的参数
	UBaseType_t uxPriority,//任务优先级，范围：0 ~ configMAX_PRIORITIES - 1
	TaskHandle_t *pxCreatedTask //任务句柄指针，就是任务的任务控制块
);
/*
返回值：
如果任务创建成功，则返回 pdPASS，
否则返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY。
*/
```



# 二、任务句柄

* 任务控制块，一个任务的控制句柄
```c
TaskHandle_t LED1Handle = NULL;//任务句柄，任务的任务控制块
```


# 三、删除任务

* 配置文件（FreeRTOSConfig.h）说明
```c
#define INCLUDE_vTaskDelete             1
```
* 函数说明
```c
//要删除的任务的句柄。如果传递 NULL，会删除任务本身。
void vTaskDelete( TaskHandle_t xTask );
```


# 四、任务挂起

* 相当于暂停任务，任务的状态会保留
```c
//挂起任务
vTaskSuspend(TaskHandle_t xTaskToSuspend);
```


# 五、在任务中恢复其他任务

* 配置文件（FreeRTOSConfig.h）说明
```c
#define INCLUDE_vTaskSuspend   1 //必须定义为 1，才可使用此函数
```
## （1）在任务中恢复其他任务的方法

```c
//恢复任务
vTaskResume(TaskHandle_t xTaskToResume);
```
## （2）挂起与恢复示例代码
```c
#include "stm32f10x.h"  
#include "Delay.h"
#include "OLED.h"
#include "Serial2.h"
#include "LED.h"
#include "FreeRTOS.h"
#include "task.h"
#include "KEY.h"

//定义三个句柄，用于任务控制块
TaskHandle_t LED1Handle = NULL;
TaskHandle_t LED2Handle = NULL;
TaskHandle_t KEYHandle = NULL;

//定义一个任务要执行的内容
void vKEYScan(void *pvParameters)
{
	while(1)
	{
		if(KEY1_Press()==1)
		{
			//挂起任务
			vTaskSuspend(LED1Handle);
		}
		if(KEY2_Press()==1)
		{
			//恢复任务
			vTaskResume(LED1Handle);
		}
	}
}

void vLED1TaskFunction( void *pvParameters )
{
	while(1)
	{
		LED1_Toggle();
		//每隔1秒
	     vTaskDelay(1000);
	}
}

void vLED2TaskFunction( void *pvParameters )
{
	while(1)
	{
		LED2_Toggle();
		//每隔1秒
	     vTaskDelay(2000);
	}
}

int main(void)
{
	Delay_s(1); //上电后等设备准备好
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); //一个project中定义一次即可，因为开启了FreeRTOS的抢占，所以要用策略4，建议裸机开发也用策略4
	
	//初始化硬件
	MYLED_Init();
	KEY_Init();
	
	//创建任务
	xTaskCreate( vLED1TaskFunction, //指向任务入口函数的指针
                         "LED1Task",//任务的描述性名称
                         400, //如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
                         NULL,//作为参数传递给所创建任务的值
                         1,//创建的任务将以该指定优先级执行。
                         &LED1Handle  //用于将句柄传递至由 xTaskCreate() 函数创建的任务
                       );
	xTaskCreate( vLED2TaskFunction, //指向任务入口函数的指针
                         "LED2Task",//任务的描述性名称
                         400, //如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
                         NULL,//作为参数传递给所创建任务的值
                         1,//创建的任务将以该指定优先级执行。
                         &LED2Handle  //用于将句柄传递至由 xTaskCreate() 函数创建的任务
                       );
	xTaskCreate( vKEYScan, //指向任务入口函数的指针
                         "KEYScanTask",//任务的描述性名称
                         400, //如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
                         NULL,//作为参数传递给所创建任务的值
                         1,//创建的任务将以该指定优先级执行。
                         &KEYHandle  //用于将句柄传递至由 xTaskCreate() 函数创建的任务
                       ); 
	
	//启动任务，开始调度器，FReeRTOS内核才会开始调度
	vTaskStartScheduler();
}
```


# 六、任务从中断中恢复

* 配置文件（FreeRTOSConfig.h）说明
```c
#define INCLUDE_vTaskSuspend    1 
#define INCLUDE_xTaskResumeFromISR  1
```
## （1）在中断处理函数中恢复其他任务

```c
/*
该函数可以在中断中调用，中断必须是抢占优先级组策略，而且中断优先级必须在0~10（因为后5位FreeRTOS占用了）
*/
BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ); //要恢复的任务句柄
/*
返回值：如果恢复任务导致上下文切换，则返回 pdTRUE，
否则返回 pdFALSE。ISR 使用此信息来确定 ISR 之后是否需要上下文切换。
*/
```
## （2）中断中恢复好的任务请求立即调度
```c
/*
portYIELD_FROM_ISR();主要用于在中断服务程序（ISR）内部请求任务调度。当在中断服务程序中调用这个函数时，它会通知 FreeRTOS 内核，在合适的时候进行上下文切换。
*/
portYIELD_FROM_ISR();
```
## （3）示例代码
```c
//此处省略了上文配置外部中断的过程，要确保该抢占优先级符合规定范围
extern TaskHandle_t LED1Handle;

void EXTI15_10_IRQHandler(void)
{
	//1.因为这里面整合了10-15共6个通道的中断处理，要筛选出12
	if(EXTI_GetITStatus(EXTI_Line12)==SET)
	{
		MySensorCount++;
		xTaskResumeFromISR(LED1Handle);
		
/*
portYIELD_FROM_ISR();主要用于在中断服务程序（ISR）内部请求任务调度。当在中断服务程序中调用这个函数时，它会通知 FreeRTOS 内核，在合适的时候进行任务切换。
*/
		portYIELD_FROM_ISR();
		
		OLED_ShowString(4,1,"exit");
		//如果不清除标识位,会一直处理中断
		EXTI_ClearITPendingBit(EXTI_Line12);
	}	
}
```


# 七、开启系统调度

```c
//启动任务，开始调度器
vTaskStartScheduler();
```