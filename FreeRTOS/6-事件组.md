# 一、简介

* 事件组是一种实现任务间通信的机制，主要用于实现多任务间的同步，但事件通信只能是事件类型的通信，无数据传输。与信号量不同的是，它可以实现一对多，多对多的同步。即一个任务可以等待多个事件的发生：可以是任意一个事件发生时唤醒任务进行事件处理；也可以是几个事件都发生后才唤醒任务进行事件处理。同样，也可以是多个任务同步多个事件。

* 在 STM32 中 ， 我 们 一 般 将configUSE_16_BIT_TICKS 定义为 0，那么 uxEventBits 是32  位的，有 24 个位用来实现事件标志组。 每一位代表一个事件， 任务通过“逻辑与”或“逻辑或”与一个或多个事件建立关联，形成一个事件组。
	* 事件的“**逻辑或**”也被称作是独立型同步，指的是任务感兴趣的所有事件任一件发生即可被唤醒；
	
	* 事件“**逻辑与**” 则被称为是关联型同步，指的是任务感兴趣的若干事件都发生时才被唤醒， 并且事件发生的时间可以不同步。*
	
	  

# 二、头文件

```c
#include "event_groups.h"
```


# 三、配置

```c
#define configUSE_16_BIT_TICKS		0
/*
事件标志组（Event Group）的位数是由`configUSE_16_BIT_TICKS`配置选项间接影响的。如果 configUSE_16_BIT_TICKS 被设置为 1 ，事件标志组为 16 位；如果 configUSE_16_BIT_TICKS 被设置为 0 ，事件标志组为 32 位。
每一位代表一个事件， 任务通过“逻辑与”或 “逻辑或”与一个或多个事件建立关联，形成一个事件组。
*/
```


# 四、相关函数

## 1.句柄

```c
//定义事件组句柄
EventGroupHandle_t xEventGroup;
```
## 2.创建事件组

```c
/*
-功能：
创建事件组

-返回值：
如果成功建立事件组，则会返回事件组的句柄（指针）；
如果内存堆没有足够的内存则会返回 NULL ，表示创建失败
*/
EventGroupHandle_t xEventGroupCreate( void );
```
## 3.设置事件位

```c
/*
-功能：
设置事件组中的一个或多个位。可以通过位或运算同时设置多个位，设置后相应的任务如果正在等待这些位被设置，则可能会被唤醒

-参数：
xEventGroup：事件组句柄，用于指定要操作的事件组
uxBitsToSet：要设置的事件标志位，通过位或运算可以同时设置多个位，例如(1 << 0)|(1 << 2)表示设置第 0 位和第 2 位

-返回值：返回设置前事件组的事件标志位，EventBits_t 是 FreeRTOS 中用于表示事件组位值的类型。
*/
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
```
## 4.清除事件位

```c
/*
-功能：
清除事件组中的一个或多个位，通常用于在某些事件处理完成后，将相应的事件标志位清除，以便下次正确地检测事件的发生

-参数：
xEventGroup：事件组句柄，指定要操作的事件组2
uxBitsToClear：要清除的事件标志位，同样可以通过位或运算指定多个位，如`(1 << 1) | (1 << 3)`表示清除第 1 位和第 3 位

-返回值：
返回清除前事件组的事件标志位
*/
EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear );
```
## 5.等待事件位

```c
/*
-功能：
等待指定的位被设置，带有可选的超时参数。任务调用此函数后会阻塞，直到等待的事件标志位满足条件，或者超时时间到达

-参数：
xEventGroup：事件组句柄，代表要等待的事件组
uxBitsToWaitFor：等待的事件标志位，任务将阻塞等待这些位被设置
xClearOnExit：退出时是否清除事件标志位，pdTRUE表示清除，pdFALSE表示不清除
xWaitForAllBits：等待所有指定的事件标志位都被设置，pdTRUE表示等待所有位都满足条件才退出等待，pdFALSE表示只要其中任意一个位被设置就退出等待
xTicksToWait`：等待的最大时间（以时钟节拍计），如果设置为portMAX_DELAY，表示无限等待

-返回值：
返回等待到的事件标志位，通过对返回值与等待的事件标志位进行按位与操作，可以判断哪些事件发生了
*/
EventBits_t xEventGroupWaitBits( const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait );
```
## 6.查询事件组标志位

```c
/*
-功能：
获取当前事件组中所有事件标志位的当前值，可用于任务在任何时候查询事件组的状态

-参数：
xEventGroup：事件组句柄，用于指定要查询的事件组

-返回值：
返回事件组中所有事件标志位的当前值
*/
EventBits_t xEventGroupGetBits( EventGroupHandle_t xEventGroup );
```
## 7.删除事件组

```c
/*
-功能：
删除一个事件组，释放其占用的内存资源。一般在不再需要使用某个事件组时调用此函数来进行清理

-参数：
xEventGroup：要删除的事件组的句柄
*/
void vEventGroupDelete( EventGroupHandle_t xEventGroup );
```


# 五、示例代码

```c
#include "stm32f10x.h"
#include "Delay.h"
#include "OLED.h"
#include "Serial2.h"
#include "KEY.h"
#include "LED.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "event_groups.h"
#include "stdio.h"

// 1.KEY1 和 KEY2 都按下， LED灯就亮。

TaskHandle_t TaskKEY1Handle = NULL;
TaskHandle_t TaskKEY2Handle = NULL;
TaskHandle_t TaskLEDHandle = NULL;

TaskHandle_t SerialPrintHandle = NULL;
TaskHandle_t CreateTaskHandle = NULL;

// 定义串口发送数据的队列句柄
QueueHandle_t xSerialMesQueue1;

// 事件组句柄
EventGroupHandle_t xCreatedEventGroup;

// 等待按键1 -- 位置在 0 位
void vTaskKEY1Function(void *pvParameters)
{

	while (1)
	{
		if (KEY1_Press() == 1)
		{
			// 事件组置位
			xEventGroupSetBits(xCreatedEventGroup, 0x01);
		}
	}
}

// 等待按键2 -- 位置在 1 位
void vTaskKEY2Function(void *pvParameters)
{

	while (1)
	{
		if (KEY2_Press() == 1)
		{
			// 事件组置位
			xEventGroupSetBits(xCreatedEventGroup, 0x02);
		}
	}
}

// 灯等待按键1和按键2置位
void vTaskLEDFunction(void *pvParameters)
{

	while (1)
	{
		// 等待按键1和按键2置位
		EventBits_t uxBits = xEventGroupWaitBits(
			xCreatedEventGroup, // 事件组句柄
			0x03,				// 等的值
			pdTRUE,				// 等成功后要不要清除 ，pdFALSE 不清除 ,pdTRUE 清除
			pdTRUE,				// and关系
			5000);
		if (uxBits == 0x01)
		{
			// 只有KEY1按下
			xQueueSendToBack(xSerialMesQueue1, "Only key1 press", portMAX_DELAY);
		}
		else if (uxBits == 0x02)
		{
			// 只有KEY2按下
			xQueueSendToBack(xSerialMesQueue1, "Only key2 press", portMAX_DELAY);
		}
		else if (uxBits == 0x03)
		{
			// KEY1和KEY2都按下
			xQueueSendToBack(xSerialMesQueue1, "Both key1 and key2 press", portMAX_DELAY);
			LED1_ON();
		}
		else
		{
			xQueueSendToBack(xSerialMesQueue1, "Not any key press", portMAX_DELAY);
		}
	}
}

void vSerialPrintFunction(void *pvParameters)
{
	char sendstr[50];
	while (1)
	{
		// 1.等待队列里面的消息
		xQueueReceive(
			xSerialMesQueue1,
			sendstr,
			portMAX_DELAY);

		// 2.发送消息
		Serial2_SendString(sendstr);
	}
}

void CreateTaskFunction(void *pvParameters)
{

	taskENTER_CRITICAL();
	// 创建任务

	xTaskCreate(
		vTaskKEY1Function, // 指向任务入口函数的指针
		"TaskKEY1",		   // 任务的描述性名称
		400,			   // 如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
		NULL,			   // 作为参数传递给所创建任务的值
		1,				   // 创建的任务将以该指定优先级执行。
		&TaskKEY1Handle	   // 用于将句柄传递至由 xTaskCreate() 函数创建的任务
	);
	xTaskCreate(
		vTaskKEY2Function, // 指向任务入口函数的指针
		"TaskKEY2",		   // 任务的描述性名称
		400,			   // 如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
		NULL,			   // 作为参数传递给所创建任务的值
		1,				   // 创建的任务将以该指定优先级执行。
		&TaskKEY2Handle	   // 用于将句柄传递至由 xTaskCreate() 函数创建的任务
	);
	xTaskCreate(
		vTaskLEDFunction, // 指向任务入口函数的指针
		"TaskLED",		  // 任务的描述性名称
		400,			  // 如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
		NULL,			  // 作为参数传递给所创建任务的值
		1,				  // 创建的任务将以该指定优先级执行。
		&TaskLEDHandle	  // 用于将句柄传递至由 xTaskCreate() 函数创建的任务
	);

	xTaskCreate(
		vSerialPrintFunction, // 指向任务入口函数的指针
		"SerialPrint",		  // 任务的描述性名称
		400,				  // 如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
		NULL,				  // 作为参数传递给所创建任务的值
		4,					  // 创建的任务将以该指定优先级执行。
		&SerialPrintHandle	  // 用于将句柄传递至由 xTaskCreate() 函数创建的任务
	);

	taskEXIT_CRITICAL();
	// 回收资源
	vTaskDelete(NULL);
}

int main(void)
{
	Delay_s(1); // 上电后等设备准备好

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 一个project中定义一次即可

	// 初始化硬件
	OLED_Init();
	OLED_Clear();

	Serial2_Init();
	KEY_Init();
	MYLED_Init();

	// 创建队列
	char message[50];
	xSerialMesQueue1 = xQueueCreate(20, sizeof(message));
	// 创建事件组
	xCreatedEventGroup = xEventGroupCreate();

	BaseType_t xReturned = xTaskCreate(CreateTaskFunction, // 指向任务入口函数的指针
									   "CreateTask",	   // 任务的描述性名称
									   400,				   // 如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
									   NULL,			   // 作为参数传递给所创建任务的值
									   1,				   // 创建的任务将以该指定优先级执行。
									   &CreateTaskHandle   // 用于将句柄传递至由 xTaskCreate() 函数创建的任务
	);
	// 判断是否创建成功

	if (xReturned != pdPASS)
	{
		OLED_ShowString(1, 1, "Create Task Fail.");
	}

	// 启动任务，开始调度器
	vTaskStartScheduler();
}

```
