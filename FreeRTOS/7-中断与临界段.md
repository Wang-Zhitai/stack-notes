# 一、FreeRTOS的中断管理
* 在STM32中，中断优先级是通过中断优先级配置寄存器的高4位 [7:4] 来配置的。因此 STM32支持最多16级中断优先级，其中数值越小表示优先级越高，即更紧急的中断。 （FreeRTOS任务调度的任务优先级相反，是数值越大越优先）
* FreeRTOS可以与STM32原生的中断机制结合使用，但它提供了自己的中断管理机制，主要 是为了提供更强大和灵活的任务调度和管理功能。
* FreeRTOS中，将PendSV和SysTick设置最低中断优先级（数值最大，15），保证系统任务切换不会阻塞系统其他中断的响应。
* FreeRTOS利用BASEPRI寄存器实现中断管理，屏蔽优先级低于某一个阈值的中断。
```c
#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	191 
/* equivalent to 0xb0, or priority 11. */
//也就是11-15的中断被FreeRTOS接管了，用户只能用前10个
```
* 在中断服务函数里边需调用FreeRTOS的API函数，必须使用带“FromISR”后缀的函数。
* 建议将所有优先级位指定为抢占优先级位，方便FreeRTOS管理。(配置NVIC_PRIORITYGROUP_4优先级组)



# 二、FreeRTOS的开关中断

* FreeRTOS 开关中断函数其实是宏定义，在 portmacro.h 中有定义，如下：
```c
#define portDISABLE_INTERRUPTS()          vPortRaiseBASEPRI() 
#define portENABLE_INTERRUPTS()           vPortSetBASEPRI(0)

//不带返回值的关中断函数，不能嵌套，不能在中断里面使用。 
portDISABLE_INTERRUPTS(); 
//带返回值的关中断函数，可以嵌套，可以在中断里面使用。  
portSET_INTERRUPT_MASK_FROM_ISR();

//不带中断保护的开中断函数     
portENABLE_INTERRUPTS();
//带中断保护的开中断函数    
portCLEAR_INTERRUPT_MASK_FROM_ISR(x);

```


# 三、临界段（CRITICAL）

* 临界段用一句话概括就是一段在执行的时候不能被打断的代码段。 在 FreeRTOS 里面，这个临界段最常出现的就是对全局变量的操作。

**那么什么情况下临界段会被打断？一个是系统调度，还有一个就是外部中断。在 FreeRTOS，系统调度，最终也是产生 PendSV 中断，在 PendSV Handler 里面实现任务 的切换，所以还是可以归结为中断。 既然这样， FreeRTOS  对临界段的保护最终还是回到了对中断的开和关的控制。**

```c
/*
进入和退出临界段的宏分中断保护版本和非中断版本， 但最终都是通过开/关中断来 
实现。进入和退出临界段是成对使用的。 只有当临界段代码都退出时，中断才会被重新使能。
*/

//进入临界段。
taskENTER_CRITICAL(); 

//退出临界段。
taskEXIT_CRITICAL(); 


//进入临界段（中断级）。
taskENTER_CRITICAL_FROM_ISR();

//退出临界段（中断级）。
taskEXIT_CRITICAL_FROM_ISR();
```